# Forth_Imitation
Сафонова Ольга Данииловна, P3207, 368764

Вариант :
forth | stack | neum | **mc** ~~-> hw~~ | instr | **binary** ~~-> struct~~ | stream | port | pstr | prob2 | ~~cache~~ 

Без усложнения

# Forth
Используется стековая архитектура, поэтому все операции выполняются на стеке.

Используется постфиксная запись операций (например, 1 + 2 будет 1 2 +)

```<number>```    - запись числовой константы в стек

```"<line>"```    - запись строчной константы в стек; записывается посимвольно, последней записью идёт длина строки

```.```           - вывод и извлечение записи с вершины стека

```key```         - чтение с устройства и запись значение в стек

```drop```        - удаление вершины стека

```dup```         - дублирование числа на вершине стека и повторая запись

```swap```        - смена позиций двух чисел навершине стека 

```rot```         - смена двух чисел вокруг второго числа с вершины стека (например, 1 2 3 rot будет 3 2 1 на стеке)

---
```+```           - извлечение двух чисел со стека, сложение и запись результата в стек

```-```           - извлечение двух чисел со стека, вычитание вершины стека из второго числа и запись результата в стек

```and```         - извлечение двух чисел со стека, воспроизведение логического "и" и запись результата в стек

```or```          - извлечение двух чисел со стека, воспроизведение логического "или" и запись результата в стек

```<```           - извлечение двух чисел со стека, сравнение вершины и второго числа на стеке (вершина < число ?) и запись результата (0 или 1) в стек

---

```<commands> if <commands> else <commands> then``` - проверка на наличие ```true``` на вершине стека (не 0); в случае ```true``` воспроизведение блока после ```if```, иначе воспроизведение блока после ```else```, в конце переход к блоку ```then```

```<max value> <start value> do <commands> loop```          - ```do```: начало цикла, сохранение двух значений с вершины стека в буфферный стек; ```loop```: инкрементирование вершины буфферного стека и проверка, что вершина меньше второго значения; в случае, если меньше, воспроизведение блока после ```do```, иначе - окончание цикла;

```variable```     - получение адреса свободной ячейки в памяти

```!```            - сохранение второй записи со стека в адрес, хранящийся в вершине стека

```?```            - чтение записи по адресу с вершины стека и запись в стек

---

```: <procedure name> <code> ;``` - объявление процедуры

```<procedure name>```            - вызов процедуры

---

- Код выполняется последовательно с возможностью ветвления и циклов
- Комментарии не поддерживаются
- Присутствует поддержка числовых целочисленных литералов от 0 до 2^32-1

## Память
- Выделяется статически, при запуске модели
- Нет разделения памяти на коммандную и память данных
- Глобальная видимость данных
- Представлена в виде массива строк, размерностью 1000
- Машинное слово не определено
- Адресация происходит по обращению по индексу массива
- Программа отображается на память, начиная с адреса 0
- Программисту доступны операции с главным стеком и памятью, начиная с адреса 100
- Числовые литералы хранятся по адресу, занятому при загрузке программы
- Строчные литералы хранятся по адресу 500 до тех пор, пока не будут загружены в стек
- При загрузке нового строчного литерала старый - затирается. Копия старого хранится в стеке
- Строки хранятся в паскаль-формате, массивом символов, где первой записью является длина строки. Хранение в строки в стеке подразумевает последним числом длину строки
- Запись в память и чтение из памяти осуществляются по адресу, хранящемуся на тот момент в вершине стека

```
---------------------
| 0     programm    |
| n     and         |
| n+m   numeric     |
| ...   constants   |
---------------------
| 100               |
| ...   variables   |
---------------------
| 500   string      |
| ...   constants   |
---------------------
```

## Система команд
- Числа занимают одну ячейку памяти
- Числа представлены в целочисленном виде от 0 до 2^32-1
- Строки представлены в виде массива символов, где начальная запись - длина строки; в стеке длина строки помещается в вершину стека
- Команды транслируются в микрокод
- Доступ к памяти осуществляется через адрес, хранящийся в вершине стека или в регистре pointer блока memory
- Есть возможность объявления процедуры через ```:``` в начале строки

Операции инструкций осуществляются над стеком: над вершиной, вершиной и вторым число, вершиной и третьим числом со стека.

Существует ветвление командами ```if <commands> else <commands> then```, где ```if``` проверяет наличие положительного числа на вершине стека, в случае ```true``` переходит на блок после ```if```, в случае ```false``` переходит на блок после ```else```, по завершению переходит на блок после ```then```.

Возможность создания цикла командами ```<max value> <min value> do <commands> loop```: если на вершине буфферного стека меньшее число, выполняется блок после ```do``` и при встрече ```loop``` - вершина стека инкрементируется; иначе, если на вершине буфферного стека большее либо равное число, выполняется блок после ```loop```.

[Микропрограммы команд, расписанные мнемониками](microcode_mnemonic.txt)

Все микрокомманды:
```
11000000010010 - snap stack pointer1
10100000010010 - snap stack1		        
11000000010100 - snap stack pointer2	    
10100000010100 - snap stack2		        
10010000010000 - snap memory		        
10001000010010 - snap tos1		        
10001000010100 - snap tos2		        
10000100010000 - snap alu		        
10000010010000 - snap io input		    
10000010001000 - snap io output		    
10000001010000 - snap command pointer	
10000000110000 - snap flags		        
10000000010000 - snap null		        
11000000001010 - reload stack pointer1	
10100000001010 - reload stack1		    
11000000001100 - reload stack pointer2	
10100000001100 - reload stack2		    
10010000001000 - reload memory		    
10010000001001 - reload read memory      
10001000001010 - reload tos1		        
10001000001100 - reload tos2		        
10000001001000 - reload command pointer	
01000000110000 - add 			        
00100000110000 - inc 			        
00010000110000 - and 			        
00001000110000 - or 			            
00000100011011 - less			        
00000010110110 - subtract 			    
00000001110110 - dec 			        
```

**Микрокоманда строится по шаблону:**

Для управляющей (нулевой бит - 1) (позиция в списке - номер бита):

1. stack pointer
2. stack
3. memory
4. TOS
5. ALU
6. IO
7. ~~deleted~~ 0
8. flags
9. for io: input; for other: snap
10. for io: output; for other: reload
11. buffer stack
12. main stack
13. special bit for reloading memory in only read format

1 | stack pointer | stack | memory | TOS | ALU | IO | 0 | flags | input/snap | output/reload | buffer | main | only read

Пример:<br>
11000000010010 <br>
1 | stack pointer | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | snap | 0 | 0 | main | 0 <br>
читается как: snap main stack pointer

Для операционной (нулевой бит - 0) (позиция в списке - номер бита):

1. add
2. increment
3. and
4. or
5. less
6. subtract
7. decrement
8. negative flag
9. zero flag
10. less flag
11. 0
12. 0
13. 0

0 | add | increment | and | or | less | substract | decrement | negative flag | zero flag | less flag | 0 | 0 | 0

Пример: <br>
01000000110000 - add <br>
0 | add | 0 | 0 | 0 | 0 | 0 | 0 | negative flag | zero flag | 0 | 0 | 0 | 0 <br>
читается как: add and touch n,z flags

Каждая инструкция транслируется в набор микрокоманд с помощью [листинга микропрограмм](microcode.txt).

Количество тактов:
```
<number>    - 9
"<line>"    - 9
.           - 10
key         - 9
drop        - 8
dup         - 8
swap        - 44
rot         - 41
+           - 11
-           - 11
and         - 11
or          - 11
<           - 11

<values> 
if          - 5
<commands>
else 
<commands>
then

<max value>
<start value>
do          - 16
<commands>
loop        - 11

variable     - 10
!            - 5
?            - 10
```
[Пример программы](program.txt)

## Транслятор
Интерфейс командной строки: ``` dotnet run <main programm>.txt <file for input>.txt <file for output>.txt <main microcode>.txt <logging file>.log/.txt```

! должен быть указан только относительный путь файлов, лежащих в той же директории, что и программа !

args:
0 - main programm
1 - file for input
2 - file for output
3 - main microcode
4 - logging file

Реализован в файле [ControlUnit.cs](ControlUnit.cs) классом Decoder


Каждая инструкция транслируется в набор микрокоманд с помощью [листинга микропрограмм](microcode.txt). Трансляция происходит по сопоставлению инструкционных слов и листинга. Условные переходы выполнены по принципу нахождения следующей значимой инструкции (например, при ```false``` после ```if``` будет искаться команда ```else```).

Процедуры, при встрече вызова, транслируются в набор инструкций

## Модель процессора
Входные данные:
- [машинный код](microcode.txt)
- [программа](program.txt)
- [файл с входными данными](input.txt)

Выходные данные:
- [журнал микроопераций и состояния процессора](logging.log)
- [вывод процессора](output.txt)

Пояснение к журналу: пометка ```warning``` ставится на состояние, чтобы выделить его при форматировании. 

### Схемы

**DataPath**

- Реализован в классе [DataPath.cs](DataPath.cs)
- Сигнал ```snap``` защёлкивает значение в регистре
- Сигнал ```operation_type``` определяет тип операции, требуемой от ALU
- Флаги: (negative, zero, less)
- Наличие флага less означает, что на вершине стека находится меньшее значение, чем на второй позиции от вершины. 

![DataPath](https://sun9-57.userapi.com/impg/V1a8OQC_YvaXiNE_F6P3gvxtMJth40LM5yeRgg/sAA8Dgjuxx4.jpg?size=936x1312&quality=96&sign=c6cfb51fec1e74d45c0e11f3790d64d8&type=album)


ControlUnit

- Реализован в классе [ControlUnit.cs](ControlUnit.cs)
- Обрабатывает флаги, полученные от DataPath

![ControlUnit](https://sun9-26.userapi.com/impg/aDcpmPfYqp-_OUmXCoJx98DpkNCQW09MWKNRxw/A9nFj1dyU6o.jpg?size=775x751&quality=96&sign=24e21d764f353cb9c793cfaceb0877eb&type=album)

**Особенности модели**
- При встрече инструкции, она тут же выполняется
- Для журнала работы модели используется Serilog
- Количество инструкций на программу ограничено

## Тестирование
Алгоритмы тестов располагаются в директории tests

- [cat](/tests/test_cat.txt)
- [hello user](/tests/test_hello_user.txt)
- [fibonacci](/tests/test_fibonacci_procedure.txt)

**Fibonacci**

[program.txt](program.txt)

```
: fib dup rot + ; 1 1 10 0 do dup . " " drop . fib loop 
```
Translated to memory:
```
1 1 10 0 do dup . " " drop . dup rot + loop 
```
Translated to microcode:
```
"11000000001010" - 1
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010010"
"10001000001010"
"10100000010010"
"10010000001000"
"10001000010010"

"11000000001010" - 1
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010010"
"10001000001010"
"10100000010010"
"10010000001000"
"10001000010010"

"11000000001010" - 10
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010010"
"10001000001010"
"10100000010010"
"10010000001000"
"10001000010010"

"11000000001010" - 0
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010010"
"10001000001010"
"10100000010010"
"10010000001000"
"10001000010010"

"11000000001100" - do
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010100"
"10100000001010"
"10100000010100"
"10001000001010"
"10001000010100"
"11000000001010"
"10100000001010"
"10001000010010"
"11000000001010"
"10000000010000"
"10000100010000"
"00000001110110"
"11000000010010"
"11000000001010"
"10100000001010"
"10001000010010"
"11000000001010"
"10000000010000"
"10000100010000"
"00000001110110"
"11000000010010"

"11000000001010" - dup
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010010"
"10001000001010"
"10100000010010"
"10001000010010"

"10001000001010" - .
"10000010001000"
"11000000001010"
"10100000001010"
"10001000010010"
"11000000001010"
"10000000010000"
"10000100010000"
"00000001110110"
"11000000010010"

"11000000001010" - " "
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010010"
"10001000001010"
"10100000010010"
"10010000001000"
"10001000010010"

"11000000001010" - drop
"10100000001010"
"10001000010010"
"11000000001010"
"10000000010000"
"10000100010000"
"00000001110110"
"11000000010010"

"10001000001010" - .
"10000010001000"
"11000000001010"
"10100000001010"
"10001000010010"
"11000000001010"
"10000000010000"
"10000100010000"
"00000001110110"
"11000000010010"

"11000000001010" - dup
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010010"
"10001000001010"
"10100000010010"
"10001000010010"

"11000000001100" - rot
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010100"
"10001000001100"
"10100000010100"
"11000000001100"
"10000000010000"
"10000100010000"
"00100000110000"
"11000000010100"
"11000000001010"
"10000000010000"
"10000100010000"
"00000001110110"
"11000000010010"
"10100000001010"
"10100000010100"
"10001000010100"
"10001000001010"
"10100000010010"
"10001000001100"
"10001000010010"
"11000000001010"

"10001000001010" - +
"10100000001010"
"10000100010000"
"01000000110000"
"10000000110000"
"10001000010010"
"11000000001010"
"10000000010000"
"10000100010000"
"00000001110110"
"11000000010010"

"10001000001100" - loop
"10000000010000"
"10000100010000"
"00100000110000"
"10001000010100"
"10001000001100"
"11000000001100"
"10100000001100"
"10001000001100"
"10000100010000"
"00000100011011"
"10000000110000"
```

Console output: ``` Tick count: 2520
Microcommands count: 1328 | Program size in bit: 18592 | Instruction count: 96 ```.

Output: ```1 2 3 5 8 13 21 34 55 89 ```.

Logging: [logging.log](logging.log)

## End
```
| ФИО                       | prog       | line count | prog size      | microinstr count | instr count | tick count | variant

| Сафонова Ольга Данииловна | Hello User | 1          | 63672 bit      | 4548             | 336         | 8801       | forth | stack | neum | mc | instr | binary | stream | port | pstr | prob2 |

| Сафонова Ольга Данииловна | cat        | 1          | 1356628 bit    | 96902            | 9375        | 221903     | forth | stack | neum | mc | instr | binary | stream | port | pstr | prob2 |

| Сафонова Ольга Данииловна | fibonacci  | 1          | 18592 bit      | 1328             | 96          | 2520       | forth | stack | neum | mc | instr | binary | stream | port | pstr | prob2 |
```